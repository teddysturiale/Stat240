---
title: 'Section 3: Data Types and Structures'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

## Variables

```{r}
# Initialize with <- or =, but <- is standard R style
x <- 4
my_favorite_number <- 8

# This does not change the value of either x or my_favorite_number
x + my_favorite_number

#But if we want to update the value
x <- x + 1
```

Capitalization matters!

```{r}
x

X
```

```{r}
# This is an illegal variable name
1a <- 3

a1 <- 3
```


### Numeric objects

```{r}
class(my_favorite_number)

class(pi)
```

Math operations can result in `NaN`, `Inf` or `-Inf` (to avoid breaking R).

```{r}
sqrt(-4)
0 / 0

1 / 0

log(0) + 8
```


### Character objects

```{r}
my_name <- "Teddy"

class(my_name)
```

Characters don't obey numeric or logical operators.  They have their own set of commands.

```{r}
easy_equation <- "2 + 2"
false_statement <- "5 < 2"

easy_equation
false_statement

char_year <- "2026"
num_year <- 2026

char_year + 10
num_year + 10
```

```{r}
nchar(my_name)

tolower(my_name)
toupper(my_name)
```

Use `paste()` to combine strings.

```{r}
my_name <- "Teddy"
my_age <- "20"

paste(my_name, "is", my_age, "years old.")
```


### Logical objects

The main objects are `TRUE` and `FALSE`, which we have seen before.

```{r}
# Is three greater than two? Yes, so return TRUE.
3 > 2

# Is two greater than three? No, so return FALSE.
2 > 3
```


## Operators

Mathematical operators let us compute a numeric result with numeric objects.

```{r}
3 + 4
5 - 8

2 * 9.5
6.8 / 2

my_favorite_number ^ 2
my_favorite_number ** 2
```


### Logical operators

Logical operators perform a comparison.

```{r}
my_height <- 60

my_height < 72

my_height < 60
```

```{r}
my_height <= 72
my_height >= 60
```

Use `==` and `!=` to check an exact equality.  This is not the same as the `=` for assigning variables!

```{r}
my_height == 66
my_height != 66
```

The value of `my_height` does not change.

The operators `&` and `|` also perform a comparison.  Instead of comparing numbers, they compare logical statements.

```{r}
# is my_height greater than 72 AND my_height + 6 less than 70?
# one of these fails, so the whole "and" condition fails.
(my_height > 72) & (my_height + 6 < 70)

# is my_height greater than 72 OR my_height + 6 less than 70?
# one of these succeeds, so the whole "or" condition succeeds.
(my_height > 72) | (my_height + 6 < 70)
```


```{r}
TRUE & FALSE
TRUE & TRUE

TRUE | TRUE
TRUE | FALSE
FALSE | FALSE
```


### Missing values

`NA` is the notation for a missing value.

```{r}
nothing <- NA
nothing + 2
```

To check for a missing value, use `is.na`.

```{r}
# Incorrect (R can't interpret this statement):
nothing == NA

# Correct
is.na(nothing)
```


## Functions

```{r}
# To use the sqrt() function, input a numeric value
sqrt(16)

# We need the correct number of arguments
sqrt()
sqrt(9, 16)
```

One of these statements returns an error.  Which one?

```{r}
sqrt(-3)

sqrt("banana")
```

We can also save the results of a function into a variable.

```{r}
# Calculate and store the value
sum_10 <- sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 

# Print it out
sum_10
```

The `seq()` function gives us a sequence of numbers.

```{r}
seq(from = 0, to = 10, by = 2)

seq(0, 21, 3)

seq(14, 49, 7)
```

Some functions have default arguments.  The default for `seq` is to start from 1.

```{r}
seq(to = 5, by = 2)
```

What is the structure of this output?


## Vectors and dataframes

A vector is a sequence of the same type of object.  Access an item by index with `[]`.

```{r}
favorite_foods <- c("noodles", "lamb stew", "corn on the cob")
prime_numbers <- c(2, 3, 5, 7, 11)

# Notice how these variables are storing the entire sequence.
favorite_foods
prime_numbers

favorite_foods[2]
prime_numbers[1]
```

If you try to combine different types, R will try to force the objects to be the same type.

```{r}
three_things = c(2, TRUE, "banana")

three_things

class(three_things)
```

### Numeric vector shortcuts

We often want to make a numeric sequence following a specific pattern.  Use `:` to get consecutive numbers and `seq` to get a sequence.

```{r}
1:10
15:30
sum(15:30)
sum(1:10)
```


### Vector operations

Any operation on a vector or multiple vectors will be done individually to the first element of each, then the second element of each, and so on.  We do not need to make a loop to do this type of operation.

```{r}
prime_numbers

prime_numbers + 13

# Use c() to add a new element
c(prime_numbers, 13)
```

This also works for logical operators.

```{r}
prime_numbers == 2

sum(prime_numbers == 2)
```

We can also use `%in%` to look for a specific item.

```{r}
2 %in% prime_numbers
1 %in% prime_numbers
```

We can also do element-wise operations over two vectors.

```{r}
onetwothree <- 1:3
fourfivesix <- 4:6

onetwothree + fourfivesix

fourfivesix - onetwothree

onetwothree * fourfivesix
```

We have to be careful if the vectors are different sizes!

```{r}
fourfive <- 4:5

onetwothree + fourfive
#vector fourfive only has two items, so while first and second items are summed correctly, the third item (3) goes to the first item in ther fourfive vector and sums it. (1+4, 2+5, 3+4)
```

### Common vector functions

```{r}
prime_numbers <- c(2, 3, 5, 7, 11)

log(prime_numbers)

min(prime_numbers)
max(prime_numbers)

mean(prime_numbers)
sum(prime_numbers)

median(prime_numbers)
```

Try to experiment with vectors!

```{r}
#evaluate [(1/2x-8)^2-20] for all integeers between 0 and 50.
x <- 0:50
x
math_function <- (0.5*(x) - 8)^2 - 20
math_function
is_negative <- math_function < 0
is_negative
sum_negative = sum(is_negative)
sum_negative

days <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
food <- c("noodles", "pea soup", "pizza", "casserole", "chocolate cake")

mean_plan = paste(days, "dinner is", food)
```


### Dataframes

Dataframes are a way to organize multiple vectors.  They're the usual tool for representing real life data.  We can build them with the `tibble` function from tidyverse.

```{r}
# "letters" is a built in R vector with the 26 lowercase letters
letters

library(tidyverse) # Need to do this to get tibble to run

alphabet <- tibble(char = letters,
                   pos = 1:26,
                   is_vowel = letters %in% c("a", "e", "i", "o", "u"))
alphabet
```

Each row represents an individual letter.  We can subset a dataframe by index with the syntax `[,]`.  We can find a row by its name with `$`.

```{r}
# Value of 7th row, 1st column
alphabet[7, 1]

# Ninth row only
alphabet[9, ]

# Third column only
alphabet[ , 3]

alphabet$is_vowel
alphabet$char
```

### Real life example

Run the following chunk, which takes data from the Stat 240 course notes.  Make sure you have the tidyverse library loaded.

```{r}
eruptions_recent <- read_csv(
  "https://bwu62.github.io/stat240-revamp/data/eruptions_recent.csv",
  show_col_types = FALSE
)

view(eruptions_recent)
```

Make a new chunk and explore the data with the functions `head`, `glimpse`, `colnames`, `dim`, `nrow`, `ncol`.

```{r}
glimpse(eruptions_recent)
head(eruptions_recent)
dim(eruptions_recent)
```









